<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DistributedJets.jl · DistributedJets</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">DistributedJets</span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DistributedJets.jl</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Distributed-block-operators"><span>Distributed block operators</span></a></li><li><a class="tocitem" href="#Tall-and-skinny-distributed-block-operators"><span>Tall and skinny distributed block operators</span></a></li><li><a class="tocitem" href="#Distributed-block-diagonal-operators"><span>Distributed block diagonal operators</span></a></li><li><a class="tocitem" href="#Methods-for-distributed-block-spaces"><span>Methods for distributed block spaces</span></a></li><li><a class="tocitem" href="#Constructing-a-distributed-block-array"><span>Constructing a distributed block array</span></a></li><li><a class="tocitem" href="#Methods-for-distributed-block-arrays"><span>Methods for distributed block arrays</span></a></li><li><a class="tocitem" href="#Methods-for-block-operators"><span>Methods for block operators</span></a></li><li><a class="tocitem" href="#Notes"><span>Notes</span></a></li><li><a class="tocitem" href="#Useful-patterns"><span>Useful patterns</span></a></li><li><a class="tocitem" href="#Create-a-block-wavefield-modeling-operator-from-the-geometry-in-a-JavaSeis-file"><span>Create a block wavefield modeling operator from the geometry in a JavaSeis file</span></a></li><li><a class="tocitem" href="#Populate-a-distributed-array-from-a-JavaSeis-file"><span>Populate a distributed array from a JavaSeis file</span></a></li></ul></li><li><a class="tocitem" href="reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DistributedJets.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DistributedJets.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ChevronETC/DistributedJets.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DistributedJets.jl"><a class="docs-heading-anchor" href="#DistributedJets.jl">DistributedJets.jl</a><a id="DistributedJets.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DistributedJets.jl" title="Permalink"></a></h1><p>This package contains distributed block operators and vectors for <a href="https://github.com/ChevronETC/Jets.jl">Jets.jl</a>.  It builds on top of the block operators in Jets.jl, providing a parallel distributed version of block operators and block vectors that are used to orchestrate distributed (in-memory) storage and compute.</p><h1 id="Distributed-block-operators"><a class="docs-heading-anchor" href="#Distributed-block-operators">Distributed block operators</a><a id="Distributed-block-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed-block-operators" title="Permalink"></a></h1><p>Similar to Jets.jl, we create a block operator using the <code>@blockop</code> macro, except that instead of using an array comprehension, we use a DArray constructor.  For example,</p><pre><code class="language-julia">using Pkg
Pkg.add([&quot;Distributed&quot;,&quot;DistributedArrays&quot;, &quot;DistributedJets&quot;,&quot;JetPack&quot;,&quot;Jets&quot;])
using Distributed
addprocs(6)
@everywhere using DistributedArrays, DistributedJets, JetPack, Jets
A = @blockop DArray(I-&gt;[JopDiagonal(rand(10)) for i in I[1], j in I[2]], (3,2), workers(), [3,2])</code></pre><p><code>A</code> is a distributed block operator with 3 column blocks and 2 row blocks.  Each block resides on a separate Julia process.  Vectors in the domain of <code>A</code> are distributed using processes corresponding the row blocks of <code>A</code>.  Likewise, vectors in the range of <code>A</code> are distributed using processes corresponding to the column blocks of <code>A</code>.</p><pre><code class="language-julia">R = domain(A) # JetBSpace consistent with the range of A
m = rand(R) # distributed block array in the domain of A
d = A*m # d is a distributed block array in the range of A</code></pre><h2 id="Tall-and-skinny-distributed-block-operators"><a class="docs-heading-anchor" href="#Tall-and-skinny-distributed-block-operators">Tall and skinny distributed block operators</a><a id="Tall-and-skinny-distributed-block-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Tall-and-skinny-distributed-block-operators" title="Permalink"></a></h2><p>We support block operators that are tall and skinny with N row blocks, and one column block.  In this case, the model space is not distributed, instead residing entirely on the master process.  For example,</p><pre><code class="language-julia">A = @blockop DArray(I-&gt;[JopDiagonal(rand(10)) for i in I[1], j in I[2]], (6,1))
R = domain(A) # JeSpace consistent with the domain of A
m = rand(domain(A)) # m is a Julia array on the master process
d = A*m # d is a distributed block array in the range of A</code></pre><h2 id="Distributed-block-diagonal-operators"><a class="docs-heading-anchor" href="#Distributed-block-diagonal-operators">Distributed block diagonal operators</a><a id="Distributed-block-diagonal-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Distributed-block-diagonal-operators" title="Permalink"></a></h2><p>we support block diagonal operators.  In this case the domain and range share the same distributed space.  Please note that in this case the paralleldistribution of the operator must be along the row direction of the block operator. In addition, one must pass the extra argument <code>isdiag=true</code> to the <code>@blockop</code> macro.  For example,</p><pre><code class="language-julia">A = @blockop DArray(I-&gt;[i==j ? JopDiagonal(rand(10)) : JopZeroBlock(JetSpace(Float64,10),JetSpace(Float64,10)) for i in I[1], j in I[2]], (6,6), workers(), [6,1]) isdiag=true
m = rand(domain(A)) # m is a distributed block array in the domain of A
d = A * m # d is a distribution block array in the range of A</code></pre><p>We note that other patterns of sparse distributed operators are not currently supported.  More generic support for sparse structures in distributed block operators would likely be best achieved by first created a sparse version of the DistributedArrays.jl package.</p><h2 id="Methods-for-distributed-block-spaces"><a class="docs-heading-anchor" href="#Methods-for-distributed-block-spaces">Methods for distributed block spaces</a><a id="Methods-for-distributed-block-spaces-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-for-distributed-block-spaces" title="Permalink"></a></h2><p>The following methods are defined for distributed block spaces,</p><pre><code class="language-julia">zeros(R) # distributed block array in R, initialized to zeros
ones(R) # distributd block array in R, initialized to ones
rand(R) # distributed block array in R, initialized to random numbers
Array(R) # distributed block array in R with un-initialized values
size(R) # the size of a distributed block space
length(R) # the length (number of dimensions) of a distributed block space
eltype(R) # the element type of the space
ndims(R) # the number of dimensions of the space
localindices(R) # the indices that are local to the calling process
localblockindices(R) # the block indices that are local to the calling process
nprocs(R) # number of Julia process associated with R
procs(R) # Julia processes associated with R</code></pre><h2 id="Constructing-a-distributed-block-array"><a class="docs-heading-anchor" href="#Constructing-a-distributed-block-array">Constructing a distributed block array</a><a id="Constructing-a-distributed-block-array-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-a-distributed-block-array" title="Permalink"></a></h2><p>The intent of this package is to be operator-centric so that a <code>DBArray</code> is constructed from the range or domain of an operator.  However, on occasion it may be useful to construct a <code>DBArray</code> independent of an operator:</p><pre><code class="language-none">A = DBArray(f, (nblks,),[pids])</code></pre><p>where <code>f</code> is a function for computing the ith block. <code>nblks</code> is the number of blocks.   <code>pids::Vector</code> is an optional parameter and is the workers to distribute the blocks across  (it defaults to <code>Distributed.workers()</code>). For example,</p><pre><code class="language-julia">@everywhere f(i)=i*rand(2)
DBArray(f,(12,),workers())</code></pre><h2 id="Methods-for-distributed-block-arrays"><a class="docs-heading-anchor" href="#Methods-for-distributed-block-arrays">Methods for distributed block arrays</a><a id="Methods-for-distributed-block-arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-for-distributed-block-arrays" title="Permalink"></a></h2><p>The following methods are defined for distributed block arrays,</p><pre><code class="language-julia">size(d)
length(d)
getblock(d, i) # retrieve block i from a block vector
getblock!(d, i, x) # retrieve block i into x from a block vector
setblock!(d, i, x) # put x into block i
localblockindices(d) # get a list of block indices that are local to the calling process
nprocs(d) # get the number of processes associated with the block vector
procs(d) # get a list of processes associated with the block vector
collect(d) # collect a block array to the calling process, returning a block array
convert(Array,d) # collect a block array to the calling process, returning a Julia array</code></pre><h2 id="Methods-for-block-operators"><a class="docs-heading-anchor" href="#Methods-for-block-operators">Methods for block operators</a><a id="Methods-for-block-operators-1"></a><a class="docs-heading-anchor-permalink" href="#Methods-for-block-operators" title="Permalink"></a></h2><pre><code class="language-julia">getblock(A,i,j) # retrive block (i,j) from a distributed block operator
localblockindices(A) # get a list of local block indices associated with the calling process
localblockindices(A,i) # get a list of local block indices associated with the calling process along dimension i
nprocs(A) # number of processes associated with A
procs(A) # list of processes associated with A
blockmap(A) # map between process id and block indices
domain(A)
range(A)
size(A)
size(A,i)
shape(A)
shape(A,i)
close(A)
state(A)
state!(A)</code></pre><h2 id="Notes"><a class="docs-heading-anchor" href="#Notes">Notes</a><a id="Notes-1"></a><a class="docs-heading-anchor-permalink" href="#Notes" title="Permalink"></a></h2><p>When using the <code>getblock</code> and <code>setblock</code> methods, one must take care to understand how data is moved between machines in the cluster.  If <code>getblock(A,i,j)</code> is called from the process that contains block <code>i,j</code> then this operation is copy-free. On the other hand if <code>getblock(A,i,j)</code> is run from a process that does not contain block <code>i,j</code>, then the call results in a copy of the block from the process that it resides on to the calling process.  The same is true for the <code>setblock!</code> method, and for the same methods when applied to distributed block arrays.</p><h2 id="Useful-patterns"><a class="docs-heading-anchor" href="#Useful-patterns">Useful patterns</a><a id="Useful-patterns-1"></a><a class="docs-heading-anchor-permalink" href="#Useful-patterns" title="Permalink"></a></h2><h3 id="Computing-cost-over-a-set-of-shots-from-a-distributed-block-array."><a class="docs-heading-anchor" href="#Computing-cost-over-a-set-of-shots-from-a-distributed-block-array.">Computing cost over a set of shots from a distributed block array.</a><a id="Computing-cost-over-a-set-of-shots-from-a-distributed-block-array.-1"></a><a class="docs-heading-anchor-permalink" href="#Computing-cost-over-a-set-of-shots-from-a-distributed-block-array." title="Permalink"></a></h3><pre><code class="language-julia">@everywhere costperblock(dmod,dobs) = 0.5*norm(dobs .- dmod)^2

@everywhere costperpid(fmod, fobs)
    _fmod = localpart(fmod)
    _fobs = localpart(fobs)
    obj = 0.0
    for iblock = 1:nblocks(_fmod,1)
        obj += costperblock(getblock(_fmod,iblock), getblock(_fobs,iblock))
    end
    obj
end

function cost(m, F, dobs)
    dmod = F*m #F is a block operators
    phi = zeros(nprocs(F))
    @sync for (ipid,pid) in enumerate(procs(F))
        @async begin
            phi[ipid] = remotecall_fetch(costperpid, pid, dmod, dobs)
        end
    end
    sum(phi)
end
</code></pre><p>Note that the above can be done in a single line. Above lines are meant to illustrate how to use the block structure.</p><pre><code class="language-julia">    cost(m,F,d) = 0.5*norm(F*m .-  d)^2</code></pre><h2 id="Create-a-block-wavefield-modeling-operator-from-the-geometry-in-a-JavaSeis-file"><a class="docs-heading-anchor" href="#Create-a-block-wavefield-modeling-operator-from-the-geometry-in-a-JavaSeis-file">Create a block wavefield modeling operator from the geometry in a JavaSeis file</a><a id="Create-a-block-wavefield-modeling-operator-from-the-geometry-in-a-JavaSeis-file-1"></a><a class="docs-heading-anchor-permalink" href="#Create-a-block-wavefield-modeling-operator-from-the-geometry-in-a-JavaSeis-file" title="Permalink"></a></h2><pre><code class="language-julia">Pkg.add([&quot;Distributed&quot;,&quot;DistributedArrays&quot;,&quot;DistributedJets&quot;,&quot;DistributedOperations,&quot;Jets&quot;,&quot;JetPackWave&quot;,&quot;TeaSeis&quot;&quot;])
using Distributed
addprocs(2)
@everywhere using DistributedArrays,DistributedJets,DistributedOperations,Jets,JetPackWave,TeaSeis

function buildblock(ishot,ρ,io)
    h = readframehdrs(io,ishot)
    JopNlProp3DAcoIsoDenQ_DEO2_FDTD(
        sz = -get(prop(io,&quot;SOU_ELEV&quot;), h, 1),
        sy = get(prop(io,&quot;SOU_Y&quot;), h, 1),
        sx = get(prop(io,&quot;SOU_X&quot;), h, 1),
        rz = [-get(prop(io,&quot;REC_ELEV&quot;), h, i) for i = 1:fold(io,h)],
        ry = [-get(prop(io,&quot;REC_Y&quot;), h, i) for i = 1:fold(io,h)],
        rx = [-get(prop(io,&quot;REC_X&quot;), h, i) for i = 1:fold(io,h)],
        ntrec = size(io,1),
        dtrec = pincs(io,1),
        dtmod = 0.0001,
        b = 1 ./ ρ,
        dz = 20.0,
        dy = 20.0,
        dx = 20.0)
end

function buildblocks(I,ρ_futures)
    io = jsopen(&quot;data.js&quot;)
    ρ = localpart(ρ_futures)
    F = [buildblock(ishot,ρ,io) for ishot in I[1], j in 1:1]
    close(io)
    F
end

io = jsopen(&quot;data.js&quot;)
nshots = size(io,3) # assume one shot per frame
close(io)

nz,ny,nx=512,512,512
ρ = 1.0*ones(nz,ny,nx)
ρ_futures = bcast(ρ)

F = @blockop DArray(I-&gt;buildblocks(I, ρ_futures), (nshots,1))</code></pre><h2 id="Populate-a-distributed-array-from-a-JavaSeis-file"><a class="docs-heading-anchor" href="#Populate-a-distributed-array-from-a-JavaSeis-file">Populate a distributed array from a JavaSeis file</a><a id="Populate-a-distributed-array-from-a-JavaSeis-file-1"></a><a class="docs-heading-anchor-permalink" href="#Populate-a-distributed-array-from-a-JavaSeis-file" title="Permalink"></a></h2><p>Given <code>F</code> built in the previous example, we can populate an array the range of <code>F</code> from a JavaSeis file.</p><pre><code class="language-julia">@everywhere function readblocks!(d)
    io = jsopen(&quot;data.js&quot;)
    for ishot in localblockindices(d)
        setblock!(d, ishot, readframetrcs(io, ishot))
    end
    close(io)
end

d = zeros(range(F))
@sync for pid in procs(d)
    @async remotecall_fetch(readblocks!, pid, d)
end</code></pre></article><nav class="docs-footer"><a class="docs-footer-nextpage" href="reference/">Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 30 May 2023 14:56">Tuesday 30 May 2023</span>. Using Julia version 1.9.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
