var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [DistributedJets]\nOrder = [:function]","category":"page"},{"location":"reference/#Base.collect-Union{Tuple{DBArray{T, A}}, Tuple{A}, Tuple{B}, Tuple{T}} where {T, B, A<:Jets.BlockArray{T, B}}","page":"Reference","title":"Base.collect","text":"collect(d)\n\ncollect the block array d to the calling process, returning a block array\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.convert-Tuple{Jets.BlockArray, DBArray}","page":"Reference","title":"Base.convert","text":"convert(Array,d)\n\ncollect the block array d and convert it to a Julia array\n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.eltype-Union{Tuple{Type{JetDSpace{T, S}}}, Tuple{S}, Tuple{T}} where {T, S}","page":"Reference","title":"Base.eltype","text":"eltype(R)\n\nreturns the element type of R \n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.size-Tuple{JetDSpace}","page":"Reference","title":"Base.size","text":"size(R)\n\nreturns the size of R\n\n\n\n\n\n","category":"method"},{"location":"reference/#Distributed.nprocs-Tuple{DBArray}","page":"Reference","title":"Distributed.nprocs","text":"nprocs(R)\n\nreturns the number of Julia processes associated with R\n\n\n\n\n\n","category":"method"},{"location":"reference/#Distributed.procs-Tuple{DBArray}","page":"Reference","title":"Distributed.procs","text":"procs(R)\n\nreturns Julia processes associated with R\n\n\n\n\n\n","category":"method"},{"location":"reference/#DistributedArrays.localindices-Tuple{DBArray}","page":"Reference","title":"DistributedArrays.localindices","text":"localindices(R)\n\nreturns the indicies of R that are local to the calling process\n\n\n\n\n\n","category":"method"},{"location":"reference/#DistributedJets.blockmap-Tuple{JetDSpace}","page":"Reference","title":"DistributedJets.blockmap","text":"blockmap(A)\n\nreturns map between process id and block indicies\n\n\n\n\n\n","category":"method"},{"location":"reference/#DistributedJets.localblockindices-Tuple{JetDSpace}","page":"Reference","title":"DistributedJets.localblockindices","text":"localblockindices(R)\n\nreturns the block indicies that are local to the calling process\n\n\n\n\n\n","category":"method"},{"location":"reference/#Jets.getblock!-Union{Tuple{A}, Tuple{B}, Tuple{T}, Tuple{DBArray{T, A}, Integer, AbstractArray}} where {T, B, A<:Jets.BlockArray{T, B}}","page":"Reference","title":"Jets.getblock!","text":"getblock!(d, i, x)\n\nget block i::Int and put it into x\n\n\n\n\n\n","category":"method"},{"location":"reference/#Jets.getblock-Union{Tuple{A}, Tuple{B}, Tuple{T}, Tuple{DBArray{T, A}, Integer}} where {T, B, A<:Jets.BlockArray{T, B}}","page":"Reference","title":"Jets.getblock","text":"getblock(d,i)\n\nretrive block i from a distributed block operator\n\n\n\n\n\n","category":"method"},{"location":"reference/#Jets.setblock!-Tuple{DBArray, Integer, Any}","page":"Reference","title":"Jets.setblock!","text":"setblock!(d,i,x)\n\nput x into block i::Int\n\n\n\n\n\n","category":"method"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"#DistributedJets.jl","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"This package contains distributed block operators and vectors for Jets.jl.  It builds on top of the block operators in Jets.jl, providing a parallel distributed version of block operators and block vectors that are used to orchestrate distributed (in-memory) storage and compute.","category":"page"},{"location":"#Distributed-block-operators","page":"DistributedJets.jl","title":"Distributed block operators","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"Similar to Jets.jl, we create a block operator using the @blockop macro, except that instead of using an array comprehension, we use a DArray constructor.  For example,","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"using Pkg\nPkg.add([\"Distributed\",\"DistributedArrays\", \"DistributedJets\",\"JetPack\",\"Jets\"])\nusing Distributed\naddprocs(6)\n@everywhere using DistributedArrays, DistributedJets, JetPack, Jets\nA = @blockop DArray(I->[JopDiagonal(rand(10)) for i in I[1], j in I[2]], (3,2), workers(), [3,2])","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"A is a distributed block operator with 3 column blocks and 2 row blocks.  Each block resides on a separate Julia process.  Vectors in the domain of A are distributed using processes corresponding the row blocks of A.  Likewise, vectors in the range of A are distributed using processes corresponding to the column blocks of A.","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"R = domain(A) # JetBSpace consistent with the range of A\nm = rand(R) # distributed block array in the domain of A\nd = A*m # d is a distributed block array in the range of A","category":"page"},{"location":"#Tall-and-skinny-distributed-block-operators","page":"DistributedJets.jl","title":"Tall and skinny distributed block operators","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"We support block operators that are tall and skinny with N row blocks, and one column block.  In this case, the model space is not distributed, instead residing entirely on the master process.  For example,","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"A = @blockop DArray(I->[JopDiagonal(rand(10)) for i in I[1], j in I[2]], (6,1))\nR = domain(A) # JeSpace consistent with the domain of A\nm = rand(domain(A)) # m is a Julia array on the master process\nd = A*m # d is a distributed block array in the range of A","category":"page"},{"location":"#Distributed-block-diagonal-operators","page":"DistributedJets.jl","title":"Distributed block diagonal operators","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"we support block diagonal operators.  In this case the domain and range share the same distributed space.  Please note that in this case the paralleldistribution of the operator must be along the row direction of the block operator. In addition, one must pass the extra argument isdiag=true to the @blockop macro.  For example,","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"A = @blockop DArray(I->[i==j ? JopDiagonal(rand(10)) : JopZeroBlock(JetSpace(Float64,10),JetSpace(Float64,10)) for i in I[1], j in I[2]], (6,6), workers(), [6,1]) isdiag=true\nm = rand(domain(A)) # m is a distributed block array in the domain of A\nd = A * m # d is a distribution block array in the range of A","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"We note that other patterns of sparse distributed operators are not currently supported.  More generic support for sparse structures in distributed block operators would likely be best achieved by first created a sparse version of the DistributedArrays.jl package.","category":"page"},{"location":"#Methods-for-distributed-block-spaces","page":"DistributedJets.jl","title":"Methods for distributed block spaces","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"The following methods are defined for distributed block spaces,","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"zeros(R) # distributed block array in R, initialized to zeros\nones(R) # distributd block array in R, initialized to ones\nrand(R) # distributed block array in R, initialized to random numbers\nArray(R) # distributed block array in R with un-initialized values\nsize(R) # the size of a distributed block space\nlength(R) # the length (number of dimensions) of a distributed block space\neltype(R) # the element type of the space\nndims(R) # the number of dimensions of the space\nlocalindices(R) # the indices that are local to the calling process\nlocalblockindices(R) # the block indices that are local to the calling process\nnprocs(R) # number of Julia process associated with R\nprocs(R) # Julia processes associated with R","category":"page"},{"location":"#Constructing-a-distributed-block-array","page":"DistributedJets.jl","title":"Constructing a distributed block array","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"The intent of this package is to be operator-centric so that a DBArray is constructed from the range or domain of an operator.  However, on occasion it may be useful to construct a DBArray independent of an operator:","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"A = DBArray(f, (nblks,),[pids])","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"where f is a function for computing the ith block. nblks is the number of blocks.   pids::Vector is an optional parameter and is the workers to distribute the blocks across  (it defaults to Distributed.workers()). For example,","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"@everywhere f(i)=i*rand(2)\nDBArray(f,(12,),workers())","category":"page"},{"location":"#Methods-for-distributed-block-arrays","page":"DistributedJets.jl","title":"Methods for distributed block arrays","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"The following methods are defined for distributed block arrays,","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"size(d)\nlength(d)\ngetblock(d, i) # retrieve block i from a block vector\ngetblock!(d, i, x) # retrieve block i into x from a block vector\nsetblock!(d, i, x) # put x into block i\nlocalblockindices(d) # get a list of block indices that are local to the calling process\nnprocs(d) # get the number of processes associated with the block vector\nprocs(d) # get a list of processes associated with the block vector\ncollect(d) # collect a block array to the calling process, returning a block array\nconvert(Array,d) # collect a block array to the calling process, returning a Julia array","category":"page"},{"location":"#Methods-for-block-operators","page":"DistributedJets.jl","title":"Methods for block operators","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"getblock(A,i,j) # retrive block (i,j) from a distributed block operator\nlocalblockindices(A) # get a list of local block indices associated with the calling process\nlocalblockindices(A,i) # get a list of local block indices associated with the calling process along dimension i\nnprocs(A) # number of processes associated with A\nprocs(A) # list of processes associated with A\nblockmap(A) # map between process id and block indices\ndomain(A)\nrange(A)\nsize(A)\nsize(A,i)\nshape(A)\nshape(A,i)\nclose(A)\nstate(A)\nstate!(A)","category":"page"},{"location":"#Notes","page":"DistributedJets.jl","title":"Notes","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"When using the getblock and setblock methods, one must take care to understand how data is moved between machines in the cluster.  If getblock(A,i,j) is called from the process that contains block i,j then this operation is copy-free. On the other hand if getblock(A,i,j) is run from a process that does not contain block i,j, then the call results in a copy of the block from the process that it resides on to the calling process.  The same is true for the setblock! method, and for the same methods when applied to distributed block arrays.","category":"page"},{"location":"#Useful-patterns","page":"DistributedJets.jl","title":"Useful patterns","text":"","category":"section"},{"location":"#Computing-cost-over-a-set-of-shots-from-a-distributed-block-array.","page":"DistributedJets.jl","title":"Computing cost over a set of shots from a distributed block array.","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"@everywhere costperblock(dmod,dobs) = 0.5*norm(dobs .- dmod)^2\n\n@everywhere costperpid(fmod, fobs)\n    _fmod = localpart(fmod)\n    _fobs = localpart(fobs)\n    obj = 0.0\n    for iblock = 1:nblocks(_fmod,1)\n        obj += costperblock(getblock(_fmod,iblock), getblock(_fobs,iblock))\n    end\n    obj\nend\n\nfunction cost(m, F, dobs)\n    dmod = F*m #F is a block operators\n    phi = zeros(nprocs(F))\n    @sync for (ipid,pid) in enumerate(procs(F))\n        @async begin\n            phi[ipid] = remotecall_fetch(costperpid, pid, dmod, dobs)\n        end\n    end\n    sum(phi)\nend\n","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"Note that the above can be done in a single line. Above lines are meant to illustrate how to use the block structure.","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"    cost(m,F,d) = 0.5*norm(F*m .-  d)^2","category":"page"},{"location":"#Create-a-block-wavefield-modeling-operator-from-the-geometry-in-a-JavaSeis-file","page":"DistributedJets.jl","title":"Create a block wavefield modeling operator from the geometry in a JavaSeis file","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"Pkg.add([\"Distributed\",\"DistributedArrays\",\"DistributedJets\",\"DistributedOperations,\"Jets\",\"JetPackWave\",\"TeaSeis\"\"])\nusing Distributed\naddprocs(2)\n@everywhere using DistributedArrays,DistributedJets,DistributedOperations,Jets,JetPackWave,TeaSeis\n\nfunction buildblock(ishot,ρ,io)\n    h = readframehdrs(io,ishot)\n    JopNlProp3DAcoIsoDenQ_DEO2_FDTD(\n        sz = -get(prop(io,\"SOU_ELEV\"), h, 1),\n        sy = get(prop(io,\"SOU_Y\"), h, 1),\n        sx = get(prop(io,\"SOU_X\"), h, 1),\n        rz = [-get(prop(io,\"REC_ELEV\"), h, i) for i = 1:fold(io,h)],\n        ry = [-get(prop(io,\"REC_Y\"), h, i) for i = 1:fold(io,h)],\n        rx = [-get(prop(io,\"REC_X\"), h, i) for i = 1:fold(io,h)],\n        ntrec = size(io,1),\n        dtrec = pincs(io,1),\n        dtmod = 0.0001,\n        b = 1 ./ ρ,\n        dz = 20.0,\n        dy = 20.0,\n        dx = 20.0)\nend\n\nfunction buildblocks(I,ρ_futures)\n    io = jsopen(\"data.js\")\n    ρ = localpart(ρ_futures)\n    F = [buildblock(ishot,ρ,io) for ishot in I[1], j in 1:1]\n    close(io)\n    F\nend\n\nio = jsopen(\"data.js\")\nnshots = size(io,3) # assume one shot per frame\nclose(io)\n\nnz,ny,nx=512,512,512\nρ = 1.0*ones(nz,ny,nx)\nρ_futures = bcast(ρ)\n\nF = @blockop DArray(I->buildblocks(I, ρ_futures), (nshots,1))","category":"page"},{"location":"#Populate-a-distributed-array-from-a-JavaSeis-file","page":"DistributedJets.jl","title":"Populate a distributed array from a JavaSeis file","text":"","category":"section"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"Given F built in the previous example, we can populate an array the range of F from a JavaSeis file.","category":"page"},{"location":"","page":"DistributedJets.jl","title":"DistributedJets.jl","text":"@everywhere function readblocks!(d)\n    io = jsopen(\"data.js\")\n    for ishot in localblockindices(d)\n        setblock!(d, ishot, readframetrcs(io, ishot))\n    end\n    close(io)\nend\n\nd = zeros(range(F))\n@sync for pid in procs(d)\n    @async remotecall_fetch(readblocks!, pid, d)\nend","category":"page"}]
}
